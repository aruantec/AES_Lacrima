using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace AES_Di.Generator
{
    /// <summary>
    /// Source generator that discovers classes marked for automatic
    /// dependency injection registration and generates helper code.
    ///
    /// It produces two kinds of generated output:
    /// - A registration helper that wires discovered types into Autofac.
    /// - A partial class per discovered type that contains an
    ///   <c>InitializeDependencies</c> method used to resolve members
    ///   marked with <c>AutoResolveAttribute</c> and perform lifecycle
    ///   initialization.
    /// </summary>
    [Generator]
    public class AutoDiSourceGenerator : IIncrementalGenerator
    {
        /// <summary>
        /// Returns an indentation string with <paramref name="level"/> groups
        /// of 4 spaces. This is a small helper used when generating formatted
        /// source code so the output is readable.
        /// </summary>
        /// <param name="level">Indentation depth (each level equals 4 spaces).</param>
        /// <returns>String containing the requested number of spaces.</returns>
        private static string Indent(int level) => new(' ', level * 4);

        /// <summary>
        /// Entry point for the incremental generator. Configures the syntax
        /// provider to locate class declarations with attributes, combines
        /// the results with the compilation, and registers the source
        /// generation callback.</summary>
        /// <param name="context">Context provided by the compiler to register
        /// incremental generation steps and outputs.</param>
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var classDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => s is ClassDeclarationSyntax { AttributeLists.Count: > 0 },
                    transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
                .Where(static m => m is not null);

            var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

            context.RegisterSourceOutput(compilationAndClasses,
                static (spc, source) => Execute(source.Left, source.Right, spc));
        }

        /// <summary>
        /// Given a syntax node that passed the predicate, obtain the
        /// corresponding <see cref="INamedTypeSymbol"/> from the semantic
        /// model. Returns null when a symbol cannot be resolved.
        /// </summary>
        /// <param name="context">Generator syntax context containing the node and semantic model.</param>
        /// <returns>The discovered named type symbol or <c>null</c> if unavailable.</returns>
        private static INamedTypeSymbol? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
        {
            var classDeclaration = (ClassDeclarationSyntax)context.Node;
            return context.SemanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
        }

        /// <summary>
        /// Build generated sources for the current compilation and discovered
        /// classes. Produces a registration helper that wires types into
        /// Autofac and emits per-type partials for dependency initialization.
        /// </summary>
        /// <param name="compilation">The compilation being analyzed.</param>
        /// <param name="classes">Collected candidate type symbols.</param>
        /// <param name="context">Context used to add generated source files.</param>
        private static void Execute(Compilation compilation, ImmutableArray<INamedTypeSymbol?> classes, SourceProductionContext context)
        {
            if (classes.IsDefaultOrEmpty) return;

            var assemblyName = compilation.AssemblyName ?? "Unknown";
            var safeAssemblyName = assemblyName.Replace(".", "_").Replace(" ", "_");

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Diagnostics;");
            sb.AppendLine("using Autofac;");
            sb.AppendLine("using AES_Core.DI;");
            sb.AppendLine("using AES_Core.Interfaces;");
            sb.AppendLine();
            sb.AppendLine($"namespace AutoGeneratedDi_{safeAssemblyName}");
            sb.AppendLine("{");
            sb.AppendLine(Indent(1) + $"public static class AutoRegister_{safeAssemblyName}");
            sb.AppendLine(Indent(1) + "{");
            sb.AppendLine(Indent(2) + "public static void Register(global::Autofac.ContainerBuilder builder)");
            sb.AppendLine(Indent(2) + "{");

            bool anyGenerated = false;
            foreach (var symbol in classes.OfType<INamedTypeSymbol>())
            {
                // Only process symbols in the current project
                if (!SymbolEqualityComparer.Default.Equals(symbol.ContainingAssembly, compilation.Assembly)) continue;

                var attributes = symbol.GetAttributes();
                var hasAutoRegister = attributes.Any(a => a.AttributeClass?.Name == "AutoRegisterAttribute" || a.AttributeClass?.ToDisplayString() == "AES_Core.DI.AutoRegisterAttribute");
                
                // Also check if any member has AutoResolveAttribute
                var hasAutoResolve = symbol.GetMembers().Any(m => m.GetAttributes().Any(a => a.AttributeClass?.Name == "AutoResolveAttribute" || a.AttributeClass?.ToDisplayString() == "AES_Core.DI.AutoResolveAttribute"));

                if (!hasAutoRegister && !hasAutoResolve) continue;

                anyGenerated = true;
                // AOT Requirement: Generate partial per class to access private fields/properties
                GenerateInjectionPartial(context, symbol);

                var fullName = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                if (hasAutoRegister)
                {
                    var interfaceName = GetRegistrationInterface(symbol);
                    sb.AppendLine(Indent(3) + $"builder.RegisterType<{fullName}>()");
                    if (interfaceName != null)
                    {
                        sb.AppendLine(Indent(3) + $".As(typeof({interfaceName}), typeof({fullName}))");
                        sb.AppendLine(Indent(3) + ".AsSelf()");
                    }
                    else
                    {
                        sb.AppendLine(Indent(3) + ".AsSelf()");
                    }
                    sb.AppendLine(Indent(3) + ".InstancePerLifetimeScope()");
                }
                else
                {
                    sb.AppendLine(Indent(3) + $"builder.RegisterType<{fullName}>().AsSelf().InstancePerLifetimeScope()");
                }

                sb.AppendLine(Indent(3) + ".OnActivated(e => {");
                sb.AppendLine(Indent(4) + $"(({fullName})e.Instance).InitializeDependencies(e.Context);");
                sb.AppendLine(Indent(3) + "});");
            }

            sb.AppendLine(Indent(2) + "}");
            sb.AppendLine(Indent(1) + "}");
            sb.AppendLine("}");

            if (anyGenerated)
            {
                context.AddSource($"AutoDi_{safeAssemblyName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));

                // Also generate a small module-initializer source that registers
                // the AutoRegister_{safeAssemblyName}.Register callback with DiLocator
                // so runtime code can avoid reflection when building the container.
                var initSb = new StringBuilder();
                initSb.AppendLine("// <auto-generated />");
                initSb.AppendLine("using System.Runtime.CompilerServices;");
                initSb.AppendLine("using AES_Core.DI;");
                initSb.AppendLine("using Autofac;");
                initSb.AppendLine();
                initSb.AppendLine($"namespace AutoGeneratedDi_{safeAssemblyName}");
                initSb.AppendLine("{");
                initSb.AppendLine(Indent(1) + $"internal static class AutoRegisterModuleInit_{safeAssemblyName}");
                initSb.AppendLine(Indent(1) + "{");
                initSb.AppendLine(Indent(2) + "[ModuleInitializer]");
                initSb.AppendLine(Indent(2) + "internal static void Init()");
                initSb.AppendLine(Indent(2) + "{");
                initSb.AppendLine(Indent(3) + $"DiLocator.AddRegistration(builder => AutoRegister_{safeAssemblyName}.Register(builder));");
                initSb.AppendLine(Indent(2) + "}");
                initSb.AppendLine(Indent(1) + "}");
                initSb.AppendLine("}");

                context.AddSource($"AutoDi_{safeAssemblyName}.ModuleInit.g.cs", SourceText.From(initSb.ToString(), Encoding.UTF8));
            }
        }

        /// <summary>
        /// Emit a partial class for <paramref name="symbol"/> that contains
        /// an <c>InitializeDependencies</c> method. The generated method
        /// resolves members annotated with <c>AutoResolveAttribute</c>,
        /// calls lifecycle hooks and registers settings where applicable.
        /// </summary>
        /// <param name="context">Source production context used to add the generated file.</param>
        /// <param name="symbol">Type symbol for which to generate the partial class.</param>
        private static void GenerateInjectionPartial(SourceProductionContext context, INamedTypeSymbol symbol)
        {
            var ns = symbol.ContainingNamespace.ToDisplayString();
            var className = symbol.Name;

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Diagnostics;");
            sb.AppendLine("using Autofac;");
            sb.AppendLine("using AES_Core.DI;");
            sb.AppendLine("using AES_Core.Interfaces;");
            sb.AppendLine();
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");
            sb.AppendLine(Indent(1) + $"partial class {className}");
            sb.AppendLine(Indent(1) + "{");
            sb.AppendLine(Indent(2) + "private bool _isInitializingDependencies;");
            sb.AppendLine(Indent(2) + "internal void InitializeDependencies(global::Autofac.IComponentContext context)");
            sb.AppendLine(Indent(2) + "{");
            sb.AppendLine(Indent(3) + "if (_isInitializingDependencies) return;");
            sb.AppendLine(Indent(3) + "_isInitializingDependencies = true;");
            sb.AppendLine(Indent(3) + "try {");

            // Handle [AutoResolve] members
            foreach (var member in symbol.GetMembers())
            {
                if (member.GetAttributes().Any(a => a.AttributeClass?.Name == "AutoResolveAttribute" || a.AttributeClass?.ToDisplayString() == "AES_Core.DI.AutoResolveAttribute"))
                {
                    ITypeSymbol type;
                    if (member is IFieldSymbol field) type = field.Type;
                    else if (member is IPropertySymbol prop) type = prop.Type;
                    else continue;

                    var typeName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    sb.AppendLine(Indent(4) + $"this.{member.Name} ??= context.ResolveOptional<{typeName}>();");
                }
            }
            // Handle LifeCycle
            sb.AppendLine(Indent(4) + "if (this is IViewModelBase vm) vm.Prepare();");

            // Handle Settings
            sb.AppendLine(Indent(4) + "var settingsService = context.ResolveOptional<ISettingsService>();");
            sb.AppendLine(Indent(4) + "if (this is ISetting settingInstance && settingsService is not null) settingsService.AddSettingsItem(settingInstance);");

            sb.AppendLine(Indent(3) + "} catch (Exception ex) {");
            sb.AppendLine(Indent(4) + $"Trace.WriteLine(\"[DI Error] Failed to initialize {className}: \" + ex.Message);");
            sb.AppendLine(Indent(3) + "} finally {");
            sb.AppendLine(Indent(4) + "_isInitializingDependencies = false;");
            sb.AppendLine(Indent(3) + "}");
            sb.AppendLine(Indent(2) + "}");
            sb.AppendLine(Indent(1) + "}");
            sb.AppendLine("}");

            context.AddSource($"{ns}.{className}.Injection.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        /// <summary>
        /// Attempt to find an interface with the conventional name of
        /// 'I{TypeName}' implemented by the provided type. If found, the
        /// fully-qualified interface name is returned for registration.
        /// </summary>
        /// <param name="symbol">Type symbol to inspect for a matching interface.</param>
        /// <returns>Fully-qualified interface name or <c>null</c> if none found.</returns>
        private static string? GetRegistrationInterface(INamedTypeSymbol symbol)
        {
            var expectedName = "I" + symbol.Name;
            var iface = symbol.Interfaces.FirstOrDefault(i => i.Name == expectedName);
            return iface?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        }
    }
}
